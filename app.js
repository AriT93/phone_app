// Generated by CoffeeScript 2.1.1
(function() {
  var Call, app, chartData, connect, db, event, express, handleOld, http, io, jade, millisForUpdates, millisUntilAbandon, millisUntilAllFlag, models, mongoose, port, socketEvent, socketListener, sys, updateChart, wSocket;

  sys = require("sys");

  http = require("http");

  event = require("events");

  io = require("socket.io");

  models = require("./models");

  mongoose = require("mongoose");

  connect = require("connect");

  express = require("express");

  jade = require("jade");

  Call = '';

  //db = mongoose.connect "mongodb://localhost/test
  db = mongoose.connect("mongodb://" + process.env.MONGO_USER + ":" + process.env.MONGO_PW + "@dbh16.mongolab.com:27167/calls");

  //"mongodb://localhost/test"
  models.defineModels(mongoose, function() {
    return Call = Call = mongoose.model('Call');
  });

  socketEvent = new event.EventEmitter();

  socketListener = socketEvent.addListener("new_call", function(data) {
    return wSocket.sockets.send(`result: ${data}`);
  });

  app = module.exports = express.createServer();

  // CONFIGURATION
  app.configure(function() {
    app.set('view engine', 'jade');
    app.set('views', `${__dirname}/views`);
    app.use(connect.bodyParser());
    app.use(connect.static(__dirname + '/public'));
    app.use(express.cookieParser());
    app.use(express.session({
      secret: "shhhhhhhhhhhhhh!"
    }));
    app.use(express.logger());
    app.use(express.methodOverride());
    return app.use(app.router);
  });

  app.configure('development', function() {
    return app.use(express.errorHandler({
      dumpExceptions: true,
      showStack: true
    }));
  });

  app.configure('production', function() {
    return app.use(express.errorHandler());
  });

  // ROUTES
  app.get('/', function(req, res) {
    return res.render('index', {
      locals: {
        title: 'Information Request'
      }
    });
  });

  app.post('/', function(req, res) {
    var c;
    c = new Call();
    c.name = req.param('name');
    c.age = req.param('age');
    c.tn = req.param('tn');
    c.city = req.param('city');
    c.state = req.param('state');
    c.zip = req.param('zip');
    c.status = 'new';
    c.allFlag = false;
    c.latitude = req.param('latitude');
    c.longitude = req.param('longitude');
    c.createdOn = new Date();
    c.save();
    socketEvent.emit("new_call", JSON.stringify(c));
    return res.redirect('/');
  });

  app.get('/agent', function(req, res) {
    return Call.find({
      "status": {
        "$in": ["new", ""]
      }
    }, function(err, calls) {
      if (err) {
        return err;
      }
      return res.render('agent', {
        locals: {
          title: "Agent",
          calls: calls
        }
      });
    });
  });

  app.get('/crc', function(req, res) {
    return Call.find({
      "allFlag": true,
      "status": {
        "$in": ["new", ""]
      }
    }, function(err, calls) {
      if (err) {
        return err;
      }
      return res.render('crc', {
        locals: {
          title: "CRC",
          calls: calls
        }
      });
    });
  });

  app.get('/charts', function(req, res) {
    return res.render('charts', {
      locals: {
        title: 'Charts'
      }
    });
  });

  // SERVER
  port = process.env.PORT || 3000;

  app.listen(port);

  console.log(`Express server listening on port ${(app.address().port)}`);

  //httpServer = http.createServer (req,res)->
  //httpServer.listen "8910"
  wSocket = io.listen(app);

  //configure socket.io

  wSocket.configure(function() {
    wSocket.enable('browser client minification');
    wSocket.set('transports', ['xhr-polling', 'jsonp-polling', 'htmlfile', 'flashsocket']);
    wSocket.set('log level', 1);
    return wSocket.set('polling duration', 10);
  });

  //socket.io codes...
  wSocket.sockets.on('connection', function(client) {
    //    wSocket.broadcast {announcement: pclient.sessionID + " from " + client.connection.remoteAddress + " connected to call routing"}
    return client.on('message', function(data) {
      var c, p;
      p = data;
      if (p['callAction'] != null) {
        return c = Call.find({
          'tn': p.callAction.tn
        }, function(err, docs) {
          var d, i, len, results;
          results = [];
          for (i = 0, len = docs.length; i < len; i++) {
            d = docs[i];
            if (d.status !== "new") {

            } else {
              d.status = "calling";
              d.save();
            }
            results.push(wSocket.sockets.send(`call: ${JSON.stringify(p)}`));
          }
          return results;
        });
      } else if (p['callDelete'] != null) {
        return c = Call.find({
          'tn': p.callDelete.tn
        }, function(err, docs) {
          var d, i, len, results;
          results = [];
          for (i = 0, len = docs.length; i < len; i++) {
            d = docs[i];
            d.status = "called";
            results.push(d.save());
          }
          return results;
        });
      } else {
        p = JSON.parse(data);
        c = new Call();
        c.name = p.name;
        c.age = p.age;
        c.tn = p.tn;
        c.city = p.city;
        c.state = p.state;
        c.zip = p.zip;
        c.status = 'new';
        c.allFlag = false;
        c.latitude = p.latitude;
        c.longitude = p.longitude;
        c.createdOn = new Date();
        c.save();
        return socketEvent.emit("new_call", JSON.stringify(c));
      }
    });
  });

  millisForUpdates = 1000 * 10;

  millisUntilAllFlag = 1000 * 30;

  millisUntilAbandon = 1000 * 60;

  chartData = {};

  handleOld = function() {
    var c, i, len, rightnow, statusToCheck, timeToCheck, x;
    rightnow = new Date();
    timeToCheck = new Date(rightnow.getTime() - millisUntilAllFlag);
    c = Call.find({
      'allFlag': false,
      'status': 'new',
      'createdOn': {
        "$lt": timeToCheck
      }
    }, function(err, docs) {
      var d, i, len, results;
      if (docs) {
        results = [];
        for (i = 0, len = docs.length; i < len; i++) {
          d = docs[i];
          d.allFlag = true;
          d.save();
          results.push(wSocket.sockets.send(`crc_call:${JSON.stringify(d)}`));
        }
        return results;
      }
    });
    timeToCheck = new Date(rightnow.getTime() - millisUntilAbandon);
    c = Call.find({
      'status': 'new',
      'createdOn': {
        "$lt": timeToCheck
      }
    }, function(err, docs) {
      var ca, d, i, len, p, results;
      if (docs) {
        results = [];
        for (i = 0, len = docs.length; i < len; i++) {
          d = docs[i];
          d.status = 'abandoned';
          d.save();
          p = d;
          ca = {};
          ca.callAction = {};
          ca.callAction.tn = p.tn;
          results.push(wSocket.sockets.send(`ab_call: ${JSON.stringify(ca)}`));
        }
        return results;
      }
    });
    statusToCheck = ["new", "calling", "called", "abandoned"];
    for (i = 0, len = statusToCheck.length; i < len; i++) {
      x = statusToCheck[i];
      updateChart(x);
    }
    return setTimeout(handleOld, millisForUpdates);
  };

  setTimeout(handleOld, millisForUpdates);

  updateChart = function(status) {
    var c;
    c = Call.count({
      'status': status
    }, function(err, count) {
      if (count !== chartData[status]) {
        return chartData[status] = count;
      }
    });
    return wSocket.sockets.send(`chart: ${JSON.stringify(chartData)}`);
  };

}).call(this);
